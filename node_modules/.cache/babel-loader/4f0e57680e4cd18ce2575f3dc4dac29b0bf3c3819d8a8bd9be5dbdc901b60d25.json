{"ast":null,"code":"/*!\n * SplitText 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\n * @author: Jack Doyle\n */\n\nlet gsap,\n  _fonts,\n  _coreInitted,\n  _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap),\n  _charSegmenter = typeof Intl !== \"undefined\" ? new Intl.Segmenter() : 0,\n  _toArray = r => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r],\n  _elements = targets => _toArray(targets).filter(e => e instanceof HTMLElement),\n  _emptyArray = [],\n  _context = function () {},\n  _spacesRegEx = /\\s+/g,\n  _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"),\n  _emptyBounds = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  },\n  _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\n    if (specialCharsRegEx) {\n      let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray),\n        i = collection.length,\n        slots,\n        word,\n        char,\n        combined;\n      if (charsFound.size) {\n        while (--i > -1) {\n          word = collection[i];\n          for (char of charsFound) {\n            if (char.startsWith(word) && char.length > word.length) {\n              slots = 0;\n              combined = word;\n              while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {}\n              if (slots && combined.length === char.length) {\n                collection[i] = char;\n                collection.splice(i + 1, slots);\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  },\n  _disallowInline = element => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"),\n  _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild),\n  _getWrapper = (type, config, collection) => {\n    let className = config[type + \"sClass\"] || \"\",\n      {\n        tag = \"div\",\n        aria = \"auto\",\n        propIndex = false\n      } = config,\n      display = type === \"line\" ? \"block\" : \"inline-block\",\n      incrementClass = className.indexOf(\"++\") > -1,\n      wrapper = text => {\n        let el = document.createElement(tag),\n          i = collection.length + 1;\n        className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\n        propIndex && el.style.setProperty(\"--\" + type, i + \"\");\n        aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\n        if (tag !== \"span\") {\n          el.style.position = \"relative\";\n          el.style.display = display;\n        }\n        el.textContent = text;\n        collection.push(el);\n        return el;\n      };\n    incrementClass && (className = className.replace(\"++\", \"\"));\n    wrapper.collection = collection;\n    return wrapper;\n  },\n  _getLineWrapper = (element, nodes, config, collection) => {\n    let lineWrapper = _getWrapper(\"line\", config, collection),\n      textAlign = window.getComputedStyle(element).textAlign || \"left\";\n    return (startIndex, endIndex) => {\n      let newLine = lineWrapper(\"\");\n      newLine.style.textAlign = textAlign;\n      element.insertBefore(newLine, nodes[startIndex]);\n      for (; startIndex < endIndex; startIndex++) {\n        newLine.appendChild(nodes[startIndex]);\n      }\n      newLine.normalize();\n    };\n  },\n  _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\n    var _a;\n    let nodes = Array.from(element.childNodes),\n      i = 0,\n      {\n        wordDelimiter,\n        reduceWhiteSpace = true,\n        prepareText\n      } = config,\n      elementBounds = element.getBoundingClientRect(),\n      lastBounds = elementBounds,\n      isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\",\n      ignoredPreviousSibling = 0,\n      wordsCollection = wordWrapper.collection,\n      wordDelimIsNotSpace,\n      wordDelimString,\n      wordDelimSplitter,\n      curNode,\n      words,\n      curWordEl,\n      startsWithSpace,\n      endsWithSpace,\n      j,\n      bounds,\n      curWordChars,\n      clonedNode,\n      curSubNode,\n      tempSubNode,\n      curTextContent,\n      wordText,\n      lastWordText,\n      k;\n    if (typeof wordDelimiter === \"object\") {\n      wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\n      wordDelimString = wordDelimiter.replaceWith || \"\";\n    } else {\n      wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\n    }\n    wordDelimIsNotSpace = wordDelimString !== \" \";\n    for (; i < nodes.length; i++) {\n      curNode = nodes[i];\n      if (curNode.nodeType === 3) {\n        curTextContent = curNode.textContent || \"\";\n        if (reduceWhiteSpace) {\n          curTextContent = curTextContent.replace(_spacesRegEx, \" \");\n        } else if (isPreformatted) {\n          curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\n        }\n        prepareText && (curTextContent = prepareText(curTextContent, element));\n        curNode.textContent = curTextContent;\n        words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\n        lastWordText = words[words.length - 1];\n        endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\n        lastWordText || words.pop();\n        lastBounds = elementBounds;\n        startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\n        startsWithSpace && _insertNodeBefore(\" \", element, curNode);\n        words[0] || words.shift();\n        _stretchToFitSpecialChars(words, specialCharsRegEx);\n        deepSlice && isNested || (curNode.textContent = \"\");\n        for (j = 1; j <= words.length; j++) {\n          wordText = words[j - 1];\n          if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\n            (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\n            _insertNodeBefore(document.createElement(\"br\"), element, curNode);\n            wordText = wordText.slice(1);\n          }\n          if (!reduceWhiteSpace && wordText === \"\") {\n            _insertNodeBefore(wordDelimString, element, curNode);\n          } else if (wordText === \" \") {\n            element.insertBefore(document.createTextNode(\" \"), curNode);\n          } else {\n            wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\n            if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\n              curWordEl = wordsCollection[wordsCollection.length - 1];\n              curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\n            } else {\n              curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\n              _insertNodeBefore(curWordEl, element, curNode);\n              ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\n            }\n            if (charWrapper) {\n              curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map(s => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\n              for (k = 0; k < curWordChars.length; k++) {\n                curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\n              }\n            }\n            if (deepSlice && isNested) {\n              curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\n              bounds = curWordEl.getBoundingClientRect();\n              if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\n                clonedNode = element.cloneNode();\n                curSubNode = element.childNodes[0];\n                while (curSubNode && curSubNode !== curWordEl) {\n                  tempSubNode = curSubNode;\n                  curSubNode = curSubNode.nextSibling;\n                  clonedNode.appendChild(tempSubNode);\n                }\n                element.parentNode.insertBefore(clonedNode, element);\n                prepForCharsOnly && _disallowInline(clonedNode);\n              }\n              lastBounds = bounds;\n            }\n            if (j < words.length || endsWithSpace) {\n              _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\n            }\n          }\n        }\n        element.removeChild(curNode);\n        ignoredPreviousSibling = 0;\n      } else if (curNode.nodeType === 1) {\n        if (ignore && ignore.indexOf(curNode) > -1) {\n          wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\n          ignoredPreviousSibling = curNode;\n        } else {\n          _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\n          ignoredPreviousSibling = 0;\n        }\n        prepForCharsOnly && _disallowInline(curNode);\n      }\n    }\n  };\nconst _SplitText = class _SplitText {\n  constructor(elements, config) {\n    this.isSplit = false;\n    _initIfNecessary();\n    this.elements = _elements(elements);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this.masks = [];\n    this.vars = config;\n    this._split = () => this.isSplit && this.split(this.vars);\n    let orig = [],\n      timerId,\n      checkWidths = () => {\n        let i = orig.length,\n          o;\n        while (i--) {\n          o = orig[i];\n          let w = o.element.offsetWidth;\n          if (w !== o.width) {\n            o.width = w;\n            this._split();\n            return;\n          }\n        }\n      };\n    this._data = {\n      orig,\n      obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\n        clearTimeout(timerId);\n        timerId = setTimeout(checkWidths, 200);\n      })\n    };\n    _context(this);\n    this.split(config);\n  }\n  split(config) {\n    this.isSplit && this.revert();\n    this.vars = config = config || this.vars || {};\n    let {\n        type = \"chars,words,lines\",\n        aria = \"auto\",\n        deepSlice = true,\n        smartWrap,\n        onSplit,\n        autoSplit = false,\n        specialChars,\n        mask\n      } = this.vars,\n      splitLines = type.indexOf(\"lines\") > -1,\n      splitCharacters = type.indexOf(\"chars\") > -1,\n      splitWords = type.indexOf(\"words\") > -1,\n      onlySplitCharacters = splitCharacters && !splitWords && !splitLines,\n      specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars),\n      finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx,\n      ignore = !!config.ignore && _elements(config.ignore),\n      {\n        orig,\n        animTime,\n        obs\n      } = this._data,\n      onSplitResult;\n    if (splitCharacters || splitWords || splitLines) {\n      this.elements.forEach((element, index) => {\n        orig[index] = {\n          element,\n          html: element.innerHTML,\n          ariaL: element.getAttribute(\"aria-label\"),\n          ariaH: element.getAttribute(\"aria-hidden\")\n        };\n        aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\n        let chars = [],\n          words = [],\n          lines = [],\n          charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null,\n          wordWrapper = _getWrapper(\"word\", config, words),\n          i,\n          curWord,\n          smartWrapSpan,\n          nextSibling;\n        _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\n        if (splitLines) {\n          let nodes = _toArray(element.childNodes),\n            wrapLine = _getLineWrapper(element, nodes, config, lines),\n            curNode,\n            toRemove = [],\n            lineStartIndex = 0,\n            allBounds = nodes.map(n => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds),\n            lastBounds = _emptyBounds;\n          for (i = 0; i < nodes.length; i++) {\n            curNode = nodes[i];\n            if (curNode.nodeType === 1) {\n              if (curNode.nodeName === \"BR\") {\n                toRemove.push(curNode);\n                wrapLine(lineStartIndex, i + 1);\n                lineStartIndex = i + 1;\n                lastBounds = allBounds[lineStartIndex];\n              } else {\n                if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {\n                  wrapLine(lineStartIndex, i);\n                  lineStartIndex = i;\n                }\n                lastBounds = allBounds[i];\n              }\n            }\n          }\n          lineStartIndex < i && wrapLine(lineStartIndex, i);\n          toRemove.forEach(el => {\n            var _a;\n            return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\n          });\n        }\n        if (!splitWords) {\n          for (i = 0; i < words.length; i++) {\n            curWord = words[i];\n            if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\n              if (smartWrap && !splitLines) {\n                smartWrapSpan = document.createElement(\"span\");\n                smartWrapSpan.style.whiteSpace = \"nowrap\";\n                while (curWord.firstChild) {\n                  smartWrapSpan.appendChild(curWord.firstChild);\n                }\n                curWord.replaceWith(smartWrapSpan);\n              } else {\n                curWord.replaceWith(...curWord.childNodes);\n              }\n            } else {\n              nextSibling = curWord.nextSibling;\n              if (nextSibling && nextSibling.nodeType === 3) {\n                nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\n                curWord.remove();\n              }\n            }\n          }\n          words.length = 0;\n          element.normalize();\n        }\n        this.lines.push(...lines);\n        this.words.push(...words);\n        this.chars.push(...chars);\n      });\n      mask && this[mask] && this.masks.push(...this[mask].map(el => {\n        let maskEl = el.cloneNode();\n        el.replaceWith(maskEl);\n        maskEl.appendChild(el);\n        el.className && (maskEl.className = el.className.replace(/(\\b\\w+\\b)/g, \"$1-mask\"));\n        maskEl.style.overflow = \"clip\";\n        return maskEl;\n      }));\n    }\n    this.isSplit = true;\n    _fonts && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\n    if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\n      this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\n    }\n    splitLines && autoSplit && this.elements.forEach((element, index) => {\n      orig[index].width = element.offsetWidth;\n      obs && obs.observe(element);\n    });\n    return this;\n  }\n  revert() {\n    var _a, _b;\n    let {\n      orig,\n      anim,\n      obs\n    } = this._data;\n    obs && obs.disconnect();\n    orig.forEach(({\n      element,\n      html,\n      ariaL,\n      ariaH\n    }) => {\n      element.innerHTML = html;\n      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\n      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\n    });\n    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\n    this.isSplit = false;\n    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\n    if (anim) {\n      this._data.animTime = anim.totalTime();\n      anim.revert();\n    }\n    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\n    return this;\n  }\n  static create(elements, config) {\n    return new _SplitText(elements, config);\n  }\n  static register(core) {\n    gsap = gsap || core || window.gsap;\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _context = gsap.core.context || _context;\n    }\n    if (!_coreInitted && window.innerWidth > 0) {\n      _fonts = document.fonts;\n      _coreInitted = true;\n    }\n  }\n};\n_SplitText.version = \"3.13.0\";\nlet SplitText = _SplitText;\nexport { SplitText, SplitText as default };","map":{"version":3,"names":["gsap","_fonts","_coreInitted","_initIfNecessary","SplitText","register","window","_charSegmenter","Intl","Segmenter","_toArray","r","document","querySelectorAll","Array","from","_elements","targets","filter","e","HTMLElement","_emptyArray","_context","_spacesRegEx","_emojiSafeRegEx","RegExp","_emptyBounds","left","top","width","height","_stretchToFitSpecialChars","collection","specialCharsRegEx","charsFound","Set","join","match","i","length","slots","word","char","combined","size","startsWith","splice","_disallowInline","element","getComputedStyle","display","style","_insertNodeBefore","newChild","parent","existingChild","insertBefore","createTextNode","_getWrapper","type","config","className","tag","aria","propIndex","incrementClass","indexOf","wrapper","text","el","createElement","setProperty","setAttribute","position","textContent","push","replace","_getLineWrapper","nodes","lineWrapper","textAlign","startIndex","endIndex","newLine","appendChild","normalize","_splitWordsAndCharsRecursively","wordWrapper","charWrapper","prepForCharsOnly","deepSlice","ignore","charSplitRegEx","isNested","_a","childNodes","wordDelimiter","reduceWhiteSpace","prepareText","elementBounds","getBoundingClientRect","lastBounds","isPreformatted","whiteSpace","substring","ignoredPreviousSibling","wordsCollection","wordDelimIsNotSpace","wordDelimString","wordDelimSplitter","curNode","words","curWordEl","startsWithSpace","endsWithSpace","j","bounds","curWordChars","clonedNode","curSubNode","tempSubNode","curTextContent","wordText","lastWordText","k","delimiter","replaceWith","nodeType","split","slice","pop","charAt","shift","previousSibling","remove","parentNode","firstChild","segment","map","s","cloneNode","nextSibling","removeChild","_SplitText","constructor","elements","isSplit","chars","lines","masks","vars","_split","orig","timerId","checkWidths","o","w","offsetWidth","_data","obs","ResizeObserver","clearTimeout","setTimeout","revert","smartWrap","onSplit","autoSplit","specialChars","mask","splitLines","splitCharacters","splitWords","onlySplitCharacters","finalCharSplitRegEx","source","animTime","onSplitResult","forEach","index","html","innerHTML","ariaL","getAttribute","ariaH","trim","curWord","smartWrapSpan","wrapLine","toRemove","lineStartIndex","allBounds","n","nodeName","maskEl","overflow","addEventListener","status","console","warn","totalTime","anim","observe","_b","disconnect","removeAttribute","removeEventListener","onRevert","call","create","core","utils","toArray","context","innerWidth","fonts","version","default"],"sources":["/Users/nourelkilany/Desktop/year 4 /java/myy/node_modules/gsap/SplitText.js"],"sourcesContent":["/*!\n * SplitText 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\n * @author: Jack Doyle\n */\n\nlet gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap), _charSegmenter = typeof Intl !== \"undefined\" ? new Intl.Segmenter() : 0, _toArray = (r) => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r], _elements = (targets) => _toArray(targets).filter((e) => e instanceof HTMLElement), _emptyArray = [], _context = function() {\n}, _spacesRegEx = /\\s+/g, _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"), _emptyBounds = { left: 0, top: 0, width: 0, height: 0 }, _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\n  if (specialCharsRegEx) {\n    let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray), i = collection.length, slots, word, char, combined;\n    if (charsFound.size) {\n      while (--i > -1) {\n        word = collection[i];\n        for (char of charsFound) {\n          if (char.startsWith(word) && char.length > word.length) {\n            slots = 0;\n            combined = word;\n            while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {\n            }\n            if (slots && combined.length === char.length) {\n              collection[i] = char;\n              collection.splice(i + 1, slots);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  return collection;\n}, _disallowInline = (element) => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"), _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild), _getWrapper = (type, config, collection) => {\n  let className = config[type + \"sClass\"] || \"\", { tag = \"div\", aria = \"auto\", propIndex = false } = config, display = type === \"line\" ? \"block\" : \"inline-block\", incrementClass = className.indexOf(\"++\") > -1, wrapper = (text) => {\n    let el = document.createElement(tag), i = collection.length + 1;\n    className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\n    propIndex && el.style.setProperty(\"--\" + type, i + \"\");\n    aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\n    if (tag !== \"span\") {\n      el.style.position = \"relative\";\n      el.style.display = display;\n    }\n    el.textContent = text;\n    collection.push(el);\n    return el;\n  };\n  incrementClass && (className = className.replace(\"++\", \"\"));\n  wrapper.collection = collection;\n  return wrapper;\n}, _getLineWrapper = (element, nodes, config, collection) => {\n  let lineWrapper = _getWrapper(\"line\", config, collection), textAlign = window.getComputedStyle(element).textAlign || \"left\";\n  return (startIndex, endIndex) => {\n    let newLine = lineWrapper(\"\");\n    newLine.style.textAlign = textAlign;\n    element.insertBefore(newLine, nodes[startIndex]);\n    for (; startIndex < endIndex; startIndex++) {\n      newLine.appendChild(nodes[startIndex]);\n    }\n    newLine.normalize();\n  };\n}, _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\n  var _a;\n  let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;\n  if (typeof wordDelimiter === \"object\") {\n    wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\n    wordDelimString = wordDelimiter.replaceWith || \"\";\n  } else {\n    wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\n  }\n  wordDelimIsNotSpace = wordDelimString !== \" \";\n  for (; i < nodes.length; i++) {\n    curNode = nodes[i];\n    if (curNode.nodeType === 3) {\n      curTextContent = curNode.textContent || \"\";\n      if (reduceWhiteSpace) {\n        curTextContent = curTextContent.replace(_spacesRegEx, \" \");\n      } else if (isPreformatted) {\n        curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\n      }\n      prepareText && (curTextContent = prepareText(curTextContent, element));\n      curNode.textContent = curTextContent;\n      words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\n      lastWordText = words[words.length - 1];\n      endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\n      lastWordText || words.pop();\n      lastBounds = elementBounds;\n      startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\n      startsWithSpace && _insertNodeBefore(\" \", element, curNode);\n      words[0] || words.shift();\n      _stretchToFitSpecialChars(words, specialCharsRegEx);\n      deepSlice && isNested || (curNode.textContent = \"\");\n      for (j = 1; j <= words.length; j++) {\n        wordText = words[j - 1];\n        if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\n          (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\n          _insertNodeBefore(document.createElement(\"br\"), element, curNode);\n          wordText = wordText.slice(1);\n        }\n        if (!reduceWhiteSpace && wordText === \"\") {\n          _insertNodeBefore(wordDelimString, element, curNode);\n        } else if (wordText === \" \") {\n          element.insertBefore(document.createTextNode(\" \"), curNode);\n        } else {\n          wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\n          if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\n            curWordEl = wordsCollection[wordsCollection.length - 1];\n            curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\n          } else {\n            curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\n            _insertNodeBefore(curWordEl, element, curNode);\n            ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\n          }\n          if (charWrapper) {\n            curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\n            for (k = 0; k < curWordChars.length; k++) {\n              curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\n            }\n          }\n          if (deepSlice && isNested) {\n            curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\n            bounds = curWordEl.getBoundingClientRect();\n            if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\n              clonedNode = element.cloneNode();\n              curSubNode = element.childNodes[0];\n              while (curSubNode && curSubNode !== curWordEl) {\n                tempSubNode = curSubNode;\n                curSubNode = curSubNode.nextSibling;\n                clonedNode.appendChild(tempSubNode);\n              }\n              element.parentNode.insertBefore(clonedNode, element);\n              prepForCharsOnly && _disallowInline(clonedNode);\n            }\n            lastBounds = bounds;\n          }\n          if (j < words.length || endsWithSpace) {\n            _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\n          }\n        }\n      }\n      element.removeChild(curNode);\n      ignoredPreviousSibling = 0;\n    } else if (curNode.nodeType === 1) {\n      if (ignore && ignore.indexOf(curNode) > -1) {\n        wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\n        ignoredPreviousSibling = curNode;\n      } else {\n        _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\n        ignoredPreviousSibling = 0;\n      }\n      prepForCharsOnly && _disallowInline(curNode);\n    }\n  }\n};\nconst _SplitText = class _SplitText {\n  constructor(elements, config) {\n    this.isSplit = false;\n    _initIfNecessary();\n    this.elements = _elements(elements);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this.masks = [];\n    this.vars = config;\n    this._split = () => this.isSplit && this.split(this.vars);\n    let orig = [], timerId, checkWidths = () => {\n      let i = orig.length, o;\n      while (i--) {\n        o = orig[i];\n        let w = o.element.offsetWidth;\n        if (w !== o.width) {\n          o.width = w;\n          this._split();\n          return;\n        }\n      }\n    };\n    this._data = { orig, obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\n      clearTimeout(timerId);\n      timerId = setTimeout(checkWidths, 200);\n    }) };\n    _context(this);\n    this.split(config);\n  }\n  split(config) {\n    this.isSplit && this.revert();\n    this.vars = config = config || this.vars || {};\n    let { type = \"chars,words,lines\", aria = \"auto\", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf(\"lines\") > -1, splitCharacters = type.indexOf(\"chars\") > -1, splitWords = type.indexOf(\"words\") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx, ignore = !!config.ignore && _elements(config.ignore), { orig, animTime, obs } = this._data, onSplitResult;\n    if (splitCharacters || splitWords || splitLines) {\n      this.elements.forEach((element, index) => {\n        orig[index] = {\n          element,\n          html: element.innerHTML,\n          ariaL: element.getAttribute(\"aria-label\"),\n          ariaH: element.getAttribute(\"aria-hidden\")\n        };\n        aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\n        let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null, wordWrapper = _getWrapper(\"word\", config, words), i, curWord, smartWrapSpan, nextSibling;\n        _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\n        if (splitLines) {\n          let nodes = _toArray(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds;\n          for (i = 0; i < nodes.length; i++) {\n            curNode = nodes[i];\n            if (curNode.nodeType === 1) {\n              if (curNode.nodeName === \"BR\") {\n                toRemove.push(curNode);\n                wrapLine(lineStartIndex, i + 1);\n                lineStartIndex = i + 1;\n                lastBounds = allBounds[lineStartIndex];\n              } else {\n                if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {\n                  wrapLine(lineStartIndex, i);\n                  lineStartIndex = i;\n                }\n                lastBounds = allBounds[i];\n              }\n            }\n          }\n          lineStartIndex < i && wrapLine(lineStartIndex, i);\n          toRemove.forEach((el) => {\n            var _a;\n            return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\n          });\n        }\n        if (!splitWords) {\n          for (i = 0; i < words.length; i++) {\n            curWord = words[i];\n            if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\n              if (smartWrap && !splitLines) {\n                smartWrapSpan = document.createElement(\"span\");\n                smartWrapSpan.style.whiteSpace = \"nowrap\";\n                while (curWord.firstChild) {\n                  smartWrapSpan.appendChild(curWord.firstChild);\n                }\n                curWord.replaceWith(smartWrapSpan);\n              } else {\n                curWord.replaceWith(...curWord.childNodes);\n              }\n            } else {\n              nextSibling = curWord.nextSibling;\n              if (nextSibling && nextSibling.nodeType === 3) {\n                nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\n                curWord.remove();\n              }\n            }\n          }\n          words.length = 0;\n          element.normalize();\n        }\n        this.lines.push(...lines);\n        this.words.push(...words);\n        this.chars.push(...chars);\n      });\n      mask && this[mask] && this.masks.push(...this[mask].map((el) => {\n        let maskEl = el.cloneNode();\n        el.replaceWith(maskEl);\n        maskEl.appendChild(el);\n        el.className && (maskEl.className = el.className.replace(/(\\b\\w+\\b)/g, \"$1-mask\"));\n        maskEl.style.overflow = \"clip\";\n        return maskEl;\n      }));\n    }\n    this.isSplit = true;\n    _fonts && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\n    if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\n      this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\n    }\n    splitLines && autoSplit && this.elements.forEach((element, index) => {\n      orig[index].width = element.offsetWidth;\n      obs && obs.observe(element);\n    });\n    return this;\n  }\n  revert() {\n    var _a, _b;\n    let { orig, anim, obs } = this._data;\n    obs && obs.disconnect();\n    orig.forEach(({ element, html, ariaL, ariaH }) => {\n      element.innerHTML = html;\n      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\n      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\n    });\n    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\n    this.isSplit = false;\n    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\n    if (anim) {\n      this._data.animTime = anim.totalTime();\n      anim.revert();\n    }\n    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\n    return this;\n  }\n  static create(elements, config) {\n    return new _SplitText(elements, config);\n  }\n  static register(core) {\n    gsap = gsap || core || window.gsap;\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _context = gsap.core.context || _context;\n    }\n    if (!_coreInitted && window.innerWidth > 0) {\n      _fonts = document.fonts;\n      _coreInitted = true;\n    }\n  }\n};\n_SplitText.version = \"3.13.0\";\nlet SplitText = _SplitText;\n\nexport { SplitText, SplitText as default };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,IAAI;EAAEC,MAAM;EAAEC,YAAY;EAAEC,gBAAgB,GAAGA,CAAA,KAAMD,YAAY,IAAIE,SAAS,CAACC,QAAQ,CAACC,MAAM,CAACN,IAAI,CAAC;EAAEO,cAAc,GAAG,OAAOC,IAAI,KAAK,WAAW,GAAG,IAAIA,IAAI,CAACC,SAAS,CAAC,CAAC,GAAG,CAAC;EAAEC,QAAQ,GAAIC,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAQ,GAAGD,QAAQ,CAACE,QAAQ,CAACC,gBAAgB,CAACF,CAAC,CAAC,CAAC,GAAG,QAAQ,IAAIA,CAAC,GAAGG,KAAK,CAACC,IAAI,CAACJ,CAAC,CAAC,GAAG,CAACA,CAAC,CAAC;EAAEK,SAAS,GAAIC,OAAO,IAAKP,QAAQ,CAACO,OAAO,CAAC,CAACC,MAAM,CAAEC,CAAC,IAAKA,CAAC,YAAYC,WAAW,CAAC;EAAEC,WAAW,GAAG,EAAE;EAAEC,QAAQ,GAAG,SAAAA,CAAA,EAAW,CACva,CAAC;EAAEC,YAAY,GAAG,MAAM;EAAEC,eAAe,GAAG,IAAIC,MAAM,CAAC,yLAAyL,EAAE,IAAI,CAAC;EAAEC,YAAY,GAAG;IAAEC,IAAI,EAAE,CAAC;IAAEC,GAAG,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,MAAM,EAAE;EAAE,CAAC;EAAEC,yBAAyB,GAAGA,CAACC,UAAU,EAAEC,iBAAiB,KAAK;IAC/W,IAAIA,iBAAiB,EAAE;MACrB,IAAIC,UAAU,GAAG,IAAIC,GAAG,CAACH,UAAU,CAACI,IAAI,CAAC,EAAE,CAAC,CAACC,KAAK,CAACJ,iBAAiB,CAAC,IAAIZ,WAAW,CAAC;QAAEiB,CAAC,GAAGN,UAAU,CAACO,MAAM;QAAEC,KAAK;QAAEC,IAAI;QAAEC,IAAI;QAAEC,QAAQ;MACzI,IAAIT,UAAU,CAACU,IAAI,EAAE;QACnB,OAAO,EAAEN,CAAC,GAAG,CAAC,CAAC,EAAE;UACfG,IAAI,GAAGT,UAAU,CAACM,CAAC,CAAC;UACpB,KAAKI,IAAI,IAAIR,UAAU,EAAE;YACvB,IAAIQ,IAAI,CAACG,UAAU,CAACJ,IAAI,CAAC,IAAIC,IAAI,CAACH,MAAM,GAAGE,IAAI,CAACF,MAAM,EAAE;cACtDC,KAAK,GAAG,CAAC;cACTG,QAAQ,GAAGF,IAAI;cACf,OAAOC,IAAI,CAACG,UAAU,CAACF,QAAQ,IAAIX,UAAU,CAACM,CAAC,GAAG,EAAEE,KAAK,CAAC,CAAC,IAAIG,QAAQ,CAACJ,MAAM,GAAGG,IAAI,CAACH,MAAM,EAAE,CAC9F;cACA,IAAIC,KAAK,IAAIG,QAAQ,CAACJ,MAAM,KAAKG,IAAI,CAACH,MAAM,EAAE;gBAC5CP,UAAU,CAACM,CAAC,CAAC,GAAGI,IAAI;gBACpBV,UAAU,CAACc,MAAM,CAACR,CAAC,GAAG,CAAC,EAAEE,KAAK,CAAC;gBAC/B;cACF;YACF;UACF;QACF;MACF;IACF;IACA,OAAOR,UAAU;EACnB,CAAC;EAAEe,eAAe,GAAIC,OAAO,IAAK1C,MAAM,CAAC2C,gBAAgB,CAACD,OAAO,CAAC,CAACE,OAAO,KAAK,QAAQ,KAAKF,OAAO,CAACG,KAAK,CAACD,OAAO,GAAG,cAAc,CAAC;EAAEE,iBAAiB,GAAGA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,aAAa,KAAKD,MAAM,CAACE,YAAY,CAAC,OAAOH,QAAQ,KAAK,QAAQ,GAAGzC,QAAQ,CAAC6C,cAAc,CAACJ,QAAQ,CAAC,GAAGA,QAAQ,EAAEE,aAAa,CAAC;EAAEG,WAAW,GAAGA,CAACC,IAAI,EAAEC,MAAM,EAAE5B,UAAU,KAAK;IACzV,IAAI6B,SAAS,GAAGD,MAAM,CAACD,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE;MAAE;QAAEG,GAAG,GAAG,KAAK;QAAEC,IAAI,GAAG,MAAM;QAAEC,SAAS,GAAG;MAAM,CAAC,GAAGJ,MAAM;MAAEV,OAAO,GAAGS,IAAI,KAAK,MAAM,GAAG,OAAO,GAAG,cAAc;MAAEM,cAAc,GAAGJ,SAAS,CAACK,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;MAAEC,OAAO,GAAIC,IAAI,IAAK;QAClO,IAAIC,EAAE,GAAGzD,QAAQ,CAAC0D,aAAa,CAACR,GAAG,CAAC;UAAExB,CAAC,GAAGN,UAAU,CAACO,MAAM,GAAG,CAAC;QAC/DsB,SAAS,KAAKQ,EAAE,CAACR,SAAS,GAAGA,SAAS,IAAII,cAAc,GAAG,GAAG,GAAGJ,SAAS,GAAGvB,CAAC,GAAG,EAAE,CAAC,CAAC;QACrF0B,SAAS,IAAIK,EAAE,CAAClB,KAAK,CAACoB,WAAW,CAAC,IAAI,GAAGZ,IAAI,EAAErB,CAAC,GAAG,EAAE,CAAC;QACtDyB,IAAI,KAAK,MAAM,IAAIM,EAAE,CAACG,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;QACzD,IAAIV,GAAG,KAAK,MAAM,EAAE;UAClBO,EAAE,CAAClB,KAAK,CAACsB,QAAQ,GAAG,UAAU;UAC9BJ,EAAE,CAAClB,KAAK,CAACD,OAAO,GAAGA,OAAO;QAC5B;QACAmB,EAAE,CAACK,WAAW,GAAGN,IAAI;QACrBpC,UAAU,CAAC2C,IAAI,CAACN,EAAE,CAAC;QACnB,OAAOA,EAAE;MACX,CAAC;IACDJ,cAAc,KAAKJ,SAAS,GAAGA,SAAS,CAACe,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IAC3DT,OAAO,CAACnC,UAAU,GAAGA,UAAU;IAC/B,OAAOmC,OAAO;EAChB,CAAC;EAAEU,eAAe,GAAGA,CAAC7B,OAAO,EAAE8B,KAAK,EAAElB,MAAM,EAAE5B,UAAU,KAAK;IAC3D,IAAI+C,WAAW,GAAGrB,WAAW,CAAC,MAAM,EAAEE,MAAM,EAAE5B,UAAU,CAAC;MAAEgD,SAAS,GAAG1E,MAAM,CAAC2C,gBAAgB,CAACD,OAAO,CAAC,CAACgC,SAAS,IAAI,MAAM;IAC3H,OAAO,CAACC,UAAU,EAAEC,QAAQ,KAAK;MAC/B,IAAIC,OAAO,GAAGJ,WAAW,CAAC,EAAE,CAAC;MAC7BI,OAAO,CAAChC,KAAK,CAAC6B,SAAS,GAAGA,SAAS;MACnChC,OAAO,CAACQ,YAAY,CAAC2B,OAAO,EAAEL,KAAK,CAACG,UAAU,CAAC,CAAC;MAChD,OAAOA,UAAU,GAAGC,QAAQ,EAAED,UAAU,EAAE,EAAE;QAC1CE,OAAO,CAACC,WAAW,CAACN,KAAK,CAACG,UAAU,CAAC,CAAC;MACxC;MACAE,OAAO,CAACE,SAAS,CAAC,CAAC;IACrB,CAAC;EACH,CAAC;EAAEC,8BAA8B,GAAGA,CAACtC,OAAO,EAAEY,MAAM,EAAE2B,WAAW,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,SAAS,EAAEC,MAAM,EAAEC,cAAc,EAAE3D,iBAAiB,EAAE4D,QAAQ,KAAK;IACnK,IAAIC,EAAE;IACN,IAAIhB,KAAK,GAAGhE,KAAK,CAACC,IAAI,CAACiC,OAAO,CAAC+C,UAAU,CAAC;MAAEzD,CAAC,GAAG,CAAC;MAAE;QAAE0D,aAAa;QAAEC,gBAAgB,GAAG,IAAI;QAAEC;MAAY,CAAC,GAAGtC,MAAM;MAAEuC,aAAa,GAAGnD,OAAO,CAACoD,qBAAqB,CAAC,CAAC;MAAEC,UAAU,GAAGF,aAAa;MAAEG,cAAc,GAAG,CAACL,gBAAgB,IAAI3F,MAAM,CAAC2C,gBAAgB,CAACD,OAAO,CAAC,CAACuD,UAAU,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK;MAAEC,sBAAsB,GAAG,CAAC;MAAEC,eAAe,GAAGnB,WAAW,CAACvD,UAAU;MAAE2E,mBAAmB;MAAEC,eAAe;MAAEC,iBAAiB;MAAEC,OAAO;MAAEC,KAAK;MAAEC,SAAS;MAAEC,eAAe;MAAEC,aAAa;MAAEC,CAAC;MAAEC,MAAM;MAAEC,YAAY;MAAEC,UAAU;MAAEC,UAAU;MAAEC,WAAW;MAAEC,cAAc;MAAEC,QAAQ;MAAEC,YAAY;MAAEC,CAAC;IAChlB,IAAI,OAAO5B,aAAa,KAAK,QAAQ,EAAE;MACrCa,iBAAiB,GAAGb,aAAa,CAAC6B,SAAS,IAAI7B,aAAa;MAC5DY,eAAe,GAAGZ,aAAa,CAAC8B,WAAW,IAAI,EAAE;IACnD,CAAC,MAAM;MACLlB,eAAe,GAAGZ,aAAa,KAAK,EAAE,GAAG,EAAE,GAAGA,aAAa,IAAI,GAAG;IACpE;IACAW,mBAAmB,GAAGC,eAAe,KAAK,GAAG;IAC7C,OAAOtE,CAAC,GAAGwC,KAAK,CAACvC,MAAM,EAAED,CAAC,EAAE,EAAE;MAC5BwE,OAAO,GAAGhC,KAAK,CAACxC,CAAC,CAAC;MAClB,IAAIwE,OAAO,CAACiB,QAAQ,KAAK,CAAC,EAAE;QAC1BN,cAAc,GAAGX,OAAO,CAACpC,WAAW,IAAI,EAAE;QAC1C,IAAIuB,gBAAgB,EAAE;UACpBwB,cAAc,GAAGA,cAAc,CAAC7C,OAAO,CAACrD,YAAY,EAAE,GAAG,CAAC;QAC5D,CAAC,MAAM,IAAI+E,cAAc,EAAE;UACzBmB,cAAc,GAAGA,cAAc,CAAC7C,OAAO,CAAC,KAAK,EAAEgC,eAAe,GAAG,IAAI,CAAC;QACxE;QACAV,WAAW,KAAKuB,cAAc,GAAGvB,WAAW,CAACuB,cAAc,EAAEzE,OAAO,CAAC,CAAC;QACtE8D,OAAO,CAACpC,WAAW,GAAG+C,cAAc;QACpCV,KAAK,GAAGH,eAAe,IAAIC,iBAAiB,GAAGY,cAAc,CAACO,KAAK,CAACnB,iBAAiB,IAAID,eAAe,CAAC,GAAGa,cAAc,CAACpF,KAAK,CAACuD,cAAc,CAAC,IAAIvE,WAAW;QAC/JsG,YAAY,GAAGZ,KAAK,CAACA,KAAK,CAACxE,MAAM,GAAG,CAAC,CAAC;QACtC2E,aAAa,GAAGP,mBAAmB,GAAGgB,YAAY,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,CAACN,YAAY;QACpFA,YAAY,IAAIZ,KAAK,CAACmB,GAAG,CAAC,CAAC;QAC3B7B,UAAU,GAAGF,aAAa;QAC1Bc,eAAe,GAAGN,mBAAmB,GAAGI,KAAK,CAAC,CAAC,CAAC,CAACoB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,CAACpB,KAAK,CAAC,CAAC,CAAC;QAC9EE,eAAe,IAAI7D,iBAAiB,CAAC,GAAG,EAAEJ,OAAO,EAAE8D,OAAO,CAAC;QAC3DC,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAACqB,KAAK,CAAC,CAAC;QACzBrG,yBAAyB,CAACgF,KAAK,EAAE9E,iBAAiB,CAAC;QACnDyD,SAAS,IAAIG,QAAQ,KAAKiB,OAAO,CAACpC,WAAW,GAAG,EAAE,CAAC;QACnD,KAAKyC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIJ,KAAK,CAACxE,MAAM,EAAE4E,CAAC,EAAE,EAAE;UAClCO,QAAQ,GAAGX,KAAK,CAACI,CAAC,GAAG,CAAC,CAAC;UACvB,IAAI,CAAClB,gBAAgB,IAAIK,cAAc,IAAIoB,QAAQ,CAACS,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;YACtE,CAACrC,EAAE,GAAGgB,OAAO,CAACuB,eAAe,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGvC,EAAE,CAACwC,MAAM,CAAC,CAAC;YAC7DlF,iBAAiB,CAACxC,QAAQ,CAAC0D,aAAa,CAAC,IAAI,CAAC,EAAEtB,OAAO,EAAE8D,OAAO,CAAC;YACjEY,QAAQ,GAAGA,QAAQ,CAACO,KAAK,CAAC,CAAC,CAAC;UAC9B;UACA,IAAI,CAAChC,gBAAgB,IAAIyB,QAAQ,KAAK,EAAE,EAAE;YACxCtE,iBAAiB,CAACwD,eAAe,EAAE5D,OAAO,EAAE8D,OAAO,CAAC;UACtD,CAAC,MAAM,IAAIY,QAAQ,KAAK,GAAG,EAAE;YAC3B1E,OAAO,CAACQ,YAAY,CAAC5C,QAAQ,CAAC6C,cAAc,CAAC,GAAG,CAAC,EAAEqD,OAAO,CAAC;UAC7D,CAAC,MAAM;YACLH,mBAAmB,IAAIe,QAAQ,CAACS,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI/E,iBAAiB,CAAC,GAAG,EAAEJ,OAAO,EAAE8D,OAAO,CAAC;YAC7F,IAAIL,sBAAsB,IAAIU,CAAC,KAAK,CAAC,IAAI,CAACF,eAAe,IAAIP,eAAe,CAACxC,OAAO,CAACuC,sBAAsB,CAAC8B,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;cAC5HvB,SAAS,GAAGN,eAAe,CAACA,eAAe,CAACnE,MAAM,GAAG,CAAC,CAAC;cACvDyE,SAAS,CAAC5B,WAAW,CAACxE,QAAQ,CAAC6C,cAAc,CAAC+B,WAAW,GAAG,EAAE,GAAGkC,QAAQ,CAAC,CAAC;YAC7E,CAAC,MAAM;cACLV,SAAS,GAAGzB,WAAW,CAACC,WAAW,GAAG,EAAE,GAAGkC,QAAQ,CAAC;cACpDtE,iBAAiB,CAAC4D,SAAS,EAAEhE,OAAO,EAAE8D,OAAO,CAAC;cAC9CL,sBAAsB,IAAIU,CAAC,KAAK,CAAC,IAAI,CAACF,eAAe,IAAID,SAAS,CAACxD,YAAY,CAACiD,sBAAsB,EAAEO,SAAS,CAACwB,UAAU,CAAC;YAC/H;YACA,IAAIhD,WAAW,EAAE;cACf6B,YAAY,GAAG9G,cAAc,GAAGwB,yBAAyB,CAAC,CAAC,GAAGxB,cAAc,CAACkI,OAAO,CAACf,QAAQ,CAAC,CAAC,CAACgB,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACF,OAAO,CAAC,EAAExG,iBAAiB,CAAC,GAAGyF,QAAQ,CAACrF,KAAK,CAACuD,cAAc,CAAC,IAAIvE,WAAW;cACzL,KAAKuG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,YAAY,CAAC9E,MAAM,EAAEqF,CAAC,EAAE,EAAE;gBACxCZ,SAAS,CAAC5B,WAAW,CAACiC,YAAY,CAACO,CAAC,CAAC,KAAK,GAAG,GAAGhH,QAAQ,CAAC6C,cAAc,CAAC,GAAG,CAAC,GAAG+B,WAAW,CAAC6B,YAAY,CAACO,CAAC,CAAC,CAAC,CAAC;cAC9G;YACF;YACA,IAAIlC,SAAS,IAAIG,QAAQ,EAAE;cACzB4B,cAAc,GAAGX,OAAO,CAACpC,WAAW,GAAG+C,cAAc,CAACjB,SAAS,CAACkB,QAAQ,CAACnF,MAAM,GAAG,CAAC,EAAEkF,cAAc,CAAClF,MAAM,CAAC;cAC3G6E,MAAM,GAAGJ,SAAS,CAACZ,qBAAqB,CAAC,CAAC;cAC1C,IAAIgB,MAAM,CAACxF,GAAG,GAAGyE,UAAU,CAACzE,GAAG,IAAIwF,MAAM,CAACzF,IAAI,IAAI0E,UAAU,CAAC1E,IAAI,EAAE;gBACjE2F,UAAU,GAAGtE,OAAO,CAAC4F,SAAS,CAAC,CAAC;gBAChCrB,UAAU,GAAGvE,OAAO,CAAC+C,UAAU,CAAC,CAAC,CAAC;gBAClC,OAAOwB,UAAU,IAAIA,UAAU,KAAKP,SAAS,EAAE;kBAC7CQ,WAAW,GAAGD,UAAU;kBACxBA,UAAU,GAAGA,UAAU,CAACsB,WAAW;kBACnCvB,UAAU,CAAClC,WAAW,CAACoC,WAAW,CAAC;gBACrC;gBACAxE,OAAO,CAACuF,UAAU,CAAC/E,YAAY,CAAC8D,UAAU,EAAEtE,OAAO,CAAC;gBACpDyC,gBAAgB,IAAI1C,eAAe,CAACuE,UAAU,CAAC;cACjD;cACAjB,UAAU,GAAGe,MAAM;YACrB;YACA,IAAID,CAAC,GAAGJ,KAAK,CAACxE,MAAM,IAAI2E,aAAa,EAAE;cACrC9D,iBAAiB,CAAC+D,CAAC,IAAIJ,KAAK,CAACxE,MAAM,GAAG,GAAG,GAAGoE,mBAAmB,IAAIe,QAAQ,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAGrB,eAAe,GAAGA,eAAe,EAAE5D,OAAO,EAAE8D,OAAO,CAAC;YAC5J;UACF;QACF;QACA9D,OAAO,CAAC8F,WAAW,CAAChC,OAAO,CAAC;QAC5BL,sBAAsB,GAAG,CAAC;MAC5B,CAAC,MAAM,IAAIK,OAAO,CAACiB,QAAQ,KAAK,CAAC,EAAE;QACjC,IAAIpC,MAAM,IAAIA,MAAM,CAACzB,OAAO,CAAC4C,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE;UAC1CJ,eAAe,CAACxC,OAAO,CAAC4C,OAAO,CAACuB,eAAe,CAAC,GAAG,CAAC,CAAC,IAAI3B,eAAe,CAACA,eAAe,CAACnE,MAAM,GAAG,CAAC,CAAC,CAAC6C,WAAW,CAAC0B,OAAO,CAAC;UACzHL,sBAAsB,GAAGK,OAAO;QAClC,CAAC,MAAM;UACLxB,8BAA8B,CAACwB,OAAO,EAAElD,MAAM,EAAE2B,WAAW,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,SAAS,EAAEC,MAAM,EAAEC,cAAc,EAAE3D,iBAAiB,EAAE,IAAI,CAAC;UACvJwE,sBAAsB,GAAG,CAAC;QAC5B;QACAhB,gBAAgB,IAAI1C,eAAe,CAAC+D,OAAO,CAAC;MAC9C;IACF;EACF,CAAC;AACD,MAAMiC,UAAU,GAAG,MAAMA,UAAU,CAAC;EAClCC,WAAWA,CAACC,QAAQ,EAAErF,MAAM,EAAE;IAC5B,IAAI,CAACsF,OAAO,GAAG,KAAK;IACpB/I,gBAAgB,CAAC,CAAC;IAClB,IAAI,CAAC8I,QAAQ,GAAGjI,SAAS,CAACiI,QAAQ,CAAC;IACnC,IAAI,CAACE,KAAK,GAAG,EAAE;IACf,IAAI,CAACpC,KAAK,GAAG,EAAE;IACf,IAAI,CAACqC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,IAAI,GAAG1F,MAAM;IAClB,IAAI,CAAC2F,MAAM,GAAG,MAAM,IAAI,CAACL,OAAO,IAAI,IAAI,CAAClB,KAAK,CAAC,IAAI,CAACsB,IAAI,CAAC;IACzD,IAAIE,IAAI,GAAG,EAAE;MAAEC,OAAO;MAAEC,WAAW,GAAGA,CAAA,KAAM;QAC1C,IAAIpH,CAAC,GAAGkH,IAAI,CAACjH,MAAM;UAAEoH,CAAC;QACtB,OAAOrH,CAAC,EAAE,EAAE;UACVqH,CAAC,GAAGH,IAAI,CAAClH,CAAC,CAAC;UACX,IAAIsH,CAAC,GAAGD,CAAC,CAAC3G,OAAO,CAAC6G,WAAW;UAC7B,IAAID,CAAC,KAAKD,CAAC,CAAC9H,KAAK,EAAE;YACjB8H,CAAC,CAAC9H,KAAK,GAAG+H,CAAC;YACX,IAAI,CAACL,MAAM,CAAC,CAAC;YACb;UACF;QACF;MACF,CAAC;IACD,IAAI,CAACO,KAAK,GAAG;MAAEN,IAAI;MAAEO,GAAG,EAAE,OAAOC,cAAc,KAAK,WAAW,IAAI,IAAIA,cAAc,CAAC,MAAM;QAC1FC,YAAY,CAACR,OAAO,CAAC;QACrBA,OAAO,GAAGS,UAAU,CAACR,WAAW,EAAE,GAAG,CAAC;MACxC,CAAC;IAAE,CAAC;IACJpI,QAAQ,CAAC,IAAI,CAAC;IACd,IAAI,CAAC0G,KAAK,CAACpE,MAAM,CAAC;EACpB;EACAoE,KAAKA,CAACpE,MAAM,EAAE;IACZ,IAAI,CAACsF,OAAO,IAAI,IAAI,CAACiB,MAAM,CAAC,CAAC;IAC7B,IAAI,CAACb,IAAI,GAAG1F,MAAM,GAAGA,MAAM,IAAI,IAAI,CAAC0F,IAAI,IAAI,CAAC,CAAC;IAC9C,IAAI;QAAE3F,IAAI,GAAG,mBAAmB;QAAEI,IAAI,GAAG,MAAM;QAAE2B,SAAS,GAAG,IAAI;QAAE0E,SAAS;QAAEC,OAAO;QAAEC,SAAS,GAAG,KAAK;QAAEC,YAAY;QAAEC;MAAK,CAAC,GAAG,IAAI,CAAClB,IAAI;MAAEmB,UAAU,GAAG9G,IAAI,CAACO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;MAAEwG,eAAe,GAAG/G,IAAI,CAACO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;MAAEyG,UAAU,GAAGhH,IAAI,CAACO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;MAAE0G,mBAAmB,GAAGF,eAAe,IAAI,CAACC,UAAU,IAAI,CAACF,UAAU;MAAExI,iBAAiB,GAAGsI,YAAY,KAAK,MAAM,IAAIA,YAAY,GAAG,IAAI9I,MAAM,CAAC,KAAK,GAAG8I,YAAY,CAACnI,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE,IAAI,CAAC,GAAGmI,YAAY,CAAC;MAAEM,mBAAmB,GAAG5I,iBAAiB,GAAG,IAAIR,MAAM,CAACQ,iBAAiB,CAAC6I,MAAM,GAAG,GAAG,GAAGtJ,eAAe,CAACsJ,MAAM,EAAE,IAAI,CAAC,GAAGtJ,eAAe;MAAEmE,MAAM,GAAG,CAAC,CAAC/B,MAAM,CAAC+B,MAAM,IAAI3E,SAAS,CAAC4C,MAAM,CAAC+B,MAAM,CAAC;MAAE;QAAE6D,IAAI;QAAEuB,QAAQ;QAAEhB;MAAI,CAAC,GAAG,IAAI,CAACD,KAAK;MAAEkB,aAAa;IACvsB,IAAIN,eAAe,IAAIC,UAAU,IAAIF,UAAU,EAAE;MAC/C,IAAI,CAACxB,QAAQ,CAACgC,OAAO,CAAC,CAACjI,OAAO,EAAEkI,KAAK,KAAK;QACxC1B,IAAI,CAAC0B,KAAK,CAAC,GAAG;UACZlI,OAAO;UACPmI,IAAI,EAAEnI,OAAO,CAACoI,SAAS;UACvBC,KAAK,EAAErI,OAAO,CAACsI,YAAY,CAAC,YAAY,CAAC;UACzCC,KAAK,EAAEvI,OAAO,CAACsI,YAAY,CAAC,aAAa;QAC3C,CAAC;QACDvH,IAAI,KAAK,MAAM,GAAGf,OAAO,CAACwB,YAAY,CAAC,YAAY,EAAE,CAACxB,OAAO,CAAC0B,WAAW,IAAI,EAAE,EAAE8G,IAAI,CAAC,CAAC,CAAC,GAAGzH,IAAI,KAAK,QAAQ,IAAIf,OAAO,CAACwB,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;QAC3J,IAAI2E,KAAK,GAAG,EAAE;UAAEpC,KAAK,GAAG,EAAE;UAAEqC,KAAK,GAAG,EAAE;UAAE5D,WAAW,GAAGkF,eAAe,GAAGhH,WAAW,CAAC,MAAM,EAAEE,MAAM,EAAEuF,KAAK,CAAC,GAAG,IAAI;UAAE5D,WAAW,GAAG7B,WAAW,CAAC,MAAM,EAAEE,MAAM,EAAEmD,KAAK,CAAC;UAAEzE,CAAC;UAAEmJ,OAAO;UAAEC,aAAa;UAAE7C,WAAW;QAC3MvD,8BAA8B,CAACtC,OAAO,EAAEY,MAAM,EAAE2B,WAAW,EAAEC,WAAW,EAAEoF,mBAAmB,EAAElF,SAAS,KAAK+E,UAAU,IAAIG,mBAAmB,CAAC,EAAEjF,MAAM,EAAEkF,mBAAmB,EAAE5I,iBAAiB,EAAE,KAAK,CAAC;QACvM,IAAIwI,UAAU,EAAE;UACd,IAAI3F,KAAK,GAAGpE,QAAQ,CAACsC,OAAO,CAAC+C,UAAU,CAAC;YAAE4F,QAAQ,GAAG9G,eAAe,CAAC7B,OAAO,EAAE8B,KAAK,EAAElB,MAAM,EAAEwF,KAAK,CAAC;YAAEtC,OAAO;YAAE8E,QAAQ,GAAG,EAAE;YAAEC,cAAc,GAAG,CAAC;YAAEC,SAAS,GAAGhH,KAAK,CAAC4D,GAAG,CAAEqD,CAAC,IAAKA,CAAC,CAAChE,QAAQ,KAAK,CAAC,GAAGgE,CAAC,CAAC3F,qBAAqB,CAAC,CAAC,GAAG1E,YAAY,CAAC;YAAE2E,UAAU,GAAG3E,YAAY;UACrQ,KAAKY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwC,KAAK,CAACvC,MAAM,EAAED,CAAC,EAAE,EAAE;YACjCwE,OAAO,GAAGhC,KAAK,CAACxC,CAAC,CAAC;YAClB,IAAIwE,OAAO,CAACiB,QAAQ,KAAK,CAAC,EAAE;cAC1B,IAAIjB,OAAO,CAACkF,QAAQ,KAAK,IAAI,EAAE;gBAC7BJ,QAAQ,CAACjH,IAAI,CAACmC,OAAO,CAAC;gBACtB6E,QAAQ,CAACE,cAAc,EAAEvJ,CAAC,GAAG,CAAC,CAAC;gBAC/BuJ,cAAc,GAAGvJ,CAAC,GAAG,CAAC;gBACtB+D,UAAU,GAAGyF,SAAS,CAACD,cAAc,CAAC;cACxC,CAAC,MAAM;gBACL,IAAIvJ,CAAC,IAAIwJ,SAAS,CAACxJ,CAAC,CAAC,CAACV,GAAG,GAAGyE,UAAU,CAACzE,GAAG,IAAIkK,SAAS,CAACxJ,CAAC,CAAC,CAACX,IAAI,IAAI0E,UAAU,CAAC1E,IAAI,EAAE;kBAClFgK,QAAQ,CAACE,cAAc,EAAEvJ,CAAC,CAAC;kBAC3BuJ,cAAc,GAAGvJ,CAAC;gBACpB;gBACA+D,UAAU,GAAGyF,SAAS,CAACxJ,CAAC,CAAC;cAC3B;YACF;UACF;UACAuJ,cAAc,GAAGvJ,CAAC,IAAIqJ,QAAQ,CAACE,cAAc,EAAEvJ,CAAC,CAAC;UACjDsJ,QAAQ,CAACX,OAAO,CAAE5G,EAAE,IAAK;YACvB,IAAIyB,EAAE;YACN,OAAO,CAACA,EAAE,GAAGzB,EAAE,CAACkE,UAAU,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGzC,EAAE,CAACgD,WAAW,CAACzE,EAAE,CAAC;UACnE,CAAC,CAAC;QACJ;QACA,IAAI,CAACsG,UAAU,EAAE;UACf,KAAKrI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyE,KAAK,CAACxE,MAAM,EAAED,CAAC,EAAE,EAAE;YACjCmJ,OAAO,GAAG1E,KAAK,CAACzE,CAAC,CAAC;YAClB,IAAIoI,eAAe,IAAI,CAACe,OAAO,CAAC5C,WAAW,IAAI4C,OAAO,CAAC5C,WAAW,CAACd,QAAQ,KAAK,CAAC,EAAE;cACjF,IAAIqC,SAAS,IAAI,CAACK,UAAU,EAAE;gBAC5BiB,aAAa,GAAG9K,QAAQ,CAAC0D,aAAa,CAAC,MAAM,CAAC;gBAC9CoH,aAAa,CAACvI,KAAK,CAACoD,UAAU,GAAG,QAAQ;gBACzC,OAAOkF,OAAO,CAACjD,UAAU,EAAE;kBACzBkD,aAAa,CAACtG,WAAW,CAACqG,OAAO,CAACjD,UAAU,CAAC;gBAC/C;gBACAiD,OAAO,CAAC3D,WAAW,CAAC4D,aAAa,CAAC;cACpC,CAAC,MAAM;gBACLD,OAAO,CAAC3D,WAAW,CAAC,GAAG2D,OAAO,CAAC1F,UAAU,CAAC;cAC5C;YACF,CAAC,MAAM;cACL8C,WAAW,GAAG4C,OAAO,CAAC5C,WAAW;cACjC,IAAIA,WAAW,IAAIA,WAAW,CAACd,QAAQ,KAAK,CAAC,EAAE;gBAC7Cc,WAAW,CAACnE,WAAW,GAAG,CAAC+G,OAAO,CAAC/G,WAAW,IAAI,EAAE,KAAKmE,WAAW,CAACnE,WAAW,IAAI,EAAE,CAAC;gBACvF+G,OAAO,CAACnD,MAAM,CAAC,CAAC;cAClB;YACF;UACF;UACAvB,KAAK,CAACxE,MAAM,GAAG,CAAC;UAChBS,OAAO,CAACqC,SAAS,CAAC,CAAC;QACrB;QACA,IAAI,CAAC+D,KAAK,CAACzE,IAAI,CAAC,GAAGyE,KAAK,CAAC;QACzB,IAAI,CAACrC,KAAK,CAACpC,IAAI,CAAC,GAAGoC,KAAK,CAAC;QACzB,IAAI,CAACoC,KAAK,CAACxE,IAAI,CAAC,GAAGwE,KAAK,CAAC;MAC3B,CAAC,CAAC;MACFqB,IAAI,IAAI,IAAI,CAACA,IAAI,CAAC,IAAI,IAAI,CAACnB,KAAK,CAAC1E,IAAI,CAAC,GAAG,IAAI,CAAC6F,IAAI,CAAC,CAAC9B,GAAG,CAAErE,EAAE,IAAK;QAC9D,IAAI4H,MAAM,GAAG5H,EAAE,CAACuE,SAAS,CAAC,CAAC;QAC3BvE,EAAE,CAACyD,WAAW,CAACmE,MAAM,CAAC;QACtBA,MAAM,CAAC7G,WAAW,CAACf,EAAE,CAAC;QACtBA,EAAE,CAACR,SAAS,KAAKoI,MAAM,CAACpI,SAAS,GAAGQ,EAAE,CAACR,SAAS,CAACe,OAAO,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;QAClFqH,MAAM,CAAC9I,KAAK,CAAC+I,QAAQ,GAAG,MAAM;QAC9B,OAAOD,MAAM;MACf,CAAC,CAAC,CAAC;IACL;IACA,IAAI,CAAC/C,OAAO,GAAG,IAAI;IACnBjJ,MAAM,KAAKqK,SAAS,GAAGrK,MAAM,CAACkM,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAAC5C,MAAM,CAAC,GAAGtJ,MAAM,CAACmM,MAAM,KAAK,SAAS,IAAIC,OAAO,CAACC,IAAI,CAAC,sCAAsC,CAAC,CAAC;IACjK,IAAI,CAACtB,aAAa,GAAGX,OAAO,IAAIA,OAAO,CAAC,IAAI,CAAC,KAAKW,aAAa,CAACuB,SAAS,EAAE;MACzE,IAAI,CAACzC,KAAK,CAAC0C,IAAI,GAAGzB,QAAQ,GAAGC,aAAa,CAACuB,SAAS,CAACxB,QAAQ,CAAC,GAAGC,aAAa;IAChF;IACAP,UAAU,IAAIH,SAAS,IAAI,IAAI,CAACrB,QAAQ,CAACgC,OAAO,CAAC,CAACjI,OAAO,EAAEkI,KAAK,KAAK;MACnE1B,IAAI,CAAC0B,KAAK,CAAC,CAACrJ,KAAK,GAAGmB,OAAO,CAAC6G,WAAW;MACvCE,GAAG,IAAIA,GAAG,CAAC0C,OAAO,CAACzJ,OAAO,CAAC;IAC7B,CAAC,CAAC;IACF,OAAO,IAAI;EACb;EACAmH,MAAMA,CAAA,EAAG;IACP,IAAIrE,EAAE,EAAE4G,EAAE;IACV,IAAI;MAAElD,IAAI;MAAEgD,IAAI;MAAEzC;IAAI,CAAC,GAAG,IAAI,CAACD,KAAK;IACpCC,GAAG,IAAIA,GAAG,CAAC4C,UAAU,CAAC,CAAC;IACvBnD,IAAI,CAACyB,OAAO,CAAC,CAAC;MAAEjI,OAAO;MAAEmI,IAAI;MAAEE,KAAK;MAAEE;IAAM,CAAC,KAAK;MAChDvI,OAAO,CAACoI,SAAS,GAAGD,IAAI;MACxBE,KAAK,GAAGrI,OAAO,CAACwB,YAAY,CAAC,YAAY,EAAE6G,KAAK,CAAC,GAAGrI,OAAO,CAAC4J,eAAe,CAAC,YAAY,CAAC;MACzFrB,KAAK,GAAGvI,OAAO,CAACwB,YAAY,CAAC,aAAa,EAAE+G,KAAK,CAAC,GAAGvI,OAAO,CAAC4J,eAAe,CAAC,aAAa,CAAC;IAC7F,CAAC,CAAC;IACF,IAAI,CAACzD,KAAK,CAAC5G,MAAM,GAAG,IAAI,CAACwE,KAAK,CAACxE,MAAM,GAAG,IAAI,CAAC6G,KAAK,CAAC7G,MAAM,GAAGiH,IAAI,CAACjH,MAAM,GAAG,IAAI,CAAC8G,KAAK,CAAC9G,MAAM,GAAG,CAAC;IAC/F,IAAI,CAAC2G,OAAO,GAAG,KAAK;IACpBjJ,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC4M,mBAAmB,CAAC,aAAa,EAAE,IAAI,CAACtD,MAAM,CAAC;IAChF,IAAIiD,IAAI,EAAE;MACR,IAAI,CAAC1C,KAAK,CAACiB,QAAQ,GAAGyB,IAAI,CAACD,SAAS,CAAC,CAAC;MACtCC,IAAI,CAACrC,MAAM,CAAC,CAAC;IACf;IACA,CAACuC,EAAE,GAAG,CAAC5G,EAAE,GAAG,IAAI,CAACwD,IAAI,EAAEwD,QAAQ,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGJ,EAAE,CAACK,IAAI,CAACjH,EAAE,EAAE,IAAI,CAAC;IACrE,OAAO,IAAI;EACb;EACA,OAAOkH,MAAMA,CAAC/D,QAAQ,EAAErF,MAAM,EAAE;IAC9B,OAAO,IAAImF,UAAU,CAACE,QAAQ,EAAErF,MAAM,CAAC;EACzC;EACA,OAAOvD,QAAQA,CAAC4M,IAAI,EAAE;IACpBjN,IAAI,GAAGA,IAAI,IAAIiN,IAAI,IAAI3M,MAAM,CAACN,IAAI;IAClC,IAAIA,IAAI,EAAE;MACRU,QAAQ,GAAGV,IAAI,CAACkN,KAAK,CAACC,OAAO;MAC7B7L,QAAQ,GAAGtB,IAAI,CAACiN,IAAI,CAACG,OAAO,IAAI9L,QAAQ;IAC1C;IACA,IAAI,CAACpB,YAAY,IAAII,MAAM,CAAC+M,UAAU,GAAG,CAAC,EAAE;MAC1CpN,MAAM,GAAGW,QAAQ,CAAC0M,KAAK;MACvBpN,YAAY,GAAG,IAAI;IACrB;EACF;AACF,CAAC;AACD6I,UAAU,CAACwE,OAAO,GAAG,QAAQ;AAC7B,IAAInN,SAAS,GAAG2I,UAAU;AAE1B,SAAS3I,SAAS,EAAEA,SAAS,IAAIoN,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}