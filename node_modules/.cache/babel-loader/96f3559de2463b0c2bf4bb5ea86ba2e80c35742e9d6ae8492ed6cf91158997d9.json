{"ast":null,"code":"var _jsxFileName = \"/Users/nourelkilany/Desktop/year 4 /java/myy/src/animation/ScrollStack.jsx\",\n  _s = $RefreshSig$();\nimport { useLayoutEffect, useRef, useCallback } from 'react';\nimport Lenis from 'lenis';\nimport './ScrollStack.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ScrollStackItem = ({\n  children,\n  itemClassName = ''\n}) => /*#__PURE__*/_jsxDEV(\"div\", {\n  className: `scroll-stack-card ${itemClassName}`.trim(),\n  children: children\n}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 6,\n  columnNumber: 3\n}, this);\n_c = ScrollStackItem;\nconst ScrollStack = ({\n  children,\n  className = '',\n  itemDistance = 100,\n  itemScale = 0.03,\n  itemStackDistance = 30,\n  stackPosition = '20%',\n  scaleEndPosition = '10%',\n  baseScale = 0.85,\n  scaleDuration = 0.5,\n  rotationAmount = 0,\n  blurAmount = 0,\n  useWindowScroll = false,\n  onStackComplete\n}) => {\n  _s();\n  const scrollerRef = useRef(null);\n  const stackCompletedRef = useRef(false);\n  const animationFrameRef = useRef(null);\n  const lenisRef = useRef(null);\n  const cardsRef = useRef([]);\n  const lastTransformsRef = useRef(new Map());\n  const isUpdatingRef = useRef(false);\n  const calculateProgress = useCallback((scrollTop, start, end) => {\n    if (scrollTop < start) return 0;\n    if (scrollTop > end) return 1;\n    return (scrollTop - start) / (end - start);\n  }, []);\n  const parsePercentage = useCallback((value, containerHeight) => {\n    if (typeof value === 'string' && value.includes('%')) {\n      return parseFloat(value) / 100 * containerHeight;\n    }\n    return parseFloat(value);\n  }, []);\n  const getScrollData = useCallback(() => {\n    if (useWindowScroll) {\n      return {\n        scrollTop: window.scrollY,\n        containerHeight: window.innerHeight,\n        scrollContainer: document.documentElement\n      };\n    } else {\n      const scroller = scrollerRef.current;\n      return {\n        scrollTop: scroller ? scroller.scrollTop : 0,\n        containerHeight: scroller ? scroller.clientHeight : window.innerHeight,\n        scrollContainer: scroller || document.documentElement\n      };\n    }\n  }, [useWindowScroll]);\n  const getElementOffset = useCallback(element => {\n    if (!element) return 0;\n    if (useWindowScroll) {\n      const rect = element.getBoundingClientRect();\n      return rect.top + window.scrollY;\n    } else {\n      // offsetTop relative to scroller container; ensure correct when scroller is used\n      let offset = 0;\n      let el = element;\n      while (el && el !== scrollerRef.current && el.offsetParent) {\n        offset += el.offsetTop;\n        el = el.offsetParent;\n      }\n      if (el === scrollerRef.current && element.offsetTop) {\n        // element.offsetTop already included, but ensure consistent calculation\n        return offset;\n      }\n      return offset || element.offsetTop || 0;\n    }\n  }, [useWindowScroll]);\n  const destroyLenis = useCallback(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n    if (lenisRef.current) {\n      try {\n        lenisRef.current.destroy();\n      } catch (e) {\n        // ignore if already destroyed\n      }\n      lenisRef.current = null;\n    }\n  }, []);\n  const setupLenis = useCallback(() => {\n    // Do nothing if lenis already exists\n    if (lenisRef.current) return lenisRef.current;\n    if (useWindowScroll) {\n      const lenis = new Lenis({\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        wheelMultiplier: 1,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075\n      });\n      const raf = time => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n      lenis.on('scroll', handleScroll);\n      animationFrameRef.current = requestAnimationFrame(raf);\n      lenisRef.current = lenis;\n      return lenis;\n    } else {\n      const scroller = scrollerRef.current;\n      if (!scroller) return null;\n      const lenis = new Lenis({\n        wrapper: scroller,\n        content: scroller.querySelector('.scroll-stack-inner'),\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        gestureOrientationHandler: true,\n        normalizeWheel: true,\n        wheelMultiplier: 1,\n        touchInertiaMultiplier: 35,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075,\n        touchInertia: 0.6\n      });\n      const raf = time => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n      lenis.on('scroll', handleScroll);\n      animationFrameRef.current = requestAnimationFrame(raf);\n      lenisRef.current = lenis;\n      return lenis;\n    }\n  }, [useWindowScroll]); // handleScroll declared later, but used via hoisting\n\n  // handleScroll must be declared before usage in setupLenis; to avoid circular reference,\n  // define here as function ref using callback which calls updateCardTransforms\n  const updateCardTransformsRef = useRef(null);\n  const handleScroll = useCallback(() => {\n    if (updateCardTransformsRef.current) updateCardTransformsRef.current();\n  }, []);\n  const updateCardTransforms = useCallback(() => {\n    var _scrollerRef$current;\n    if (!cardsRef.current.length || isUpdatingRef.current) return;\n    isUpdatingRef.current = true;\n    const {\n      scrollTop,\n      containerHeight\n    } = getScrollData();\n    const stackPositionPx = parsePercentage(stackPosition, containerHeight);\n    const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\n    const endElement = useWindowScroll ? document.querySelector('.scroll-stack-end') : (_scrollerRef$current = scrollerRef.current) === null || _scrollerRef$current === void 0 ? void 0 : _scrollerRef$current.querySelector('.scroll-stack-end');\n    const endElementTop = endElement ? getElementOffset(endElement) : 0;\n    cardsRef.current.forEach((card, i) => {\n      if (!card) return;\n      const cardTop = getElementOffset(card);\n      const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\n      const triggerEnd = cardTop - scaleEndPositionPx;\n      const pinStart = triggerStart;\n      const pinEnd = endElementTop - containerHeight / 2;\n      const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\n      const targetScale = baseScale + i * itemScale;\n      const scale = 1 - scaleProgress * (1 - targetScale);\n      const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\n      let blur = 0;\n      if (blurAmount) {\n        let topCardIndex = 0;\n        for (let j = 0; j < cardsRef.current.length; j++) {\n          const jCardTop = getElementOffset(cardsRef.current[j]);\n          const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\n          if (scrollTop >= jTriggerStart) {\n            topCardIndex = j;\n          }\n        }\n        if (i < topCardIndex) {\n          const depthInStack = topCardIndex - i;\n          blur = Math.max(0, depthInStack * blurAmount);\n        }\n      }\n      let translateY = 0;\n      const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\n      if (isPinned) {\n        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\n      } else if (scrollTop > pinEnd) {\n        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\n      }\n      const newTransform = {\n        translateY: Math.round(translateY * 100) / 100,\n        scale: Math.round(scale * 1000) / 1000,\n        rotation: Math.round(rotation * 100) / 100,\n        blur: Math.round(blur * 100) / 100\n      };\n      const lastTransform = lastTransformsRef.current.get(i);\n      const hasChanged = !lastTransform || Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 || Math.abs(lastTransform.scale - newTransform.scale) > 0.001 || Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 || Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\n      if (hasChanged) {\n        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;\n        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';\n        card.style.transform = transform;\n        card.style.filter = filter;\n        lastTransformsRef.current.set(i, newTransform);\n      }\n\n      // LAST CARD: determine completion\n      if (i === cardsRef.current.length - 1) {\n        // The stack is considered complete when the page scrolls past the pinEnd\n        if (scrollTop > pinEnd) {\n          if (!stackCompletedRef.current) {\n            stackCompletedRef.current = true;\n            // Call the callback\n            onStackComplete === null || onStackComplete === void 0 ? void 0 : onStackComplete();\n\n            // Destroy Lenis to release control to native page scroll\n            destroyLenis();\n          }\n        } else {\n          // If user scrolls back up above pinEnd, mark as not completed and re-init Lenis\n          if (stackCompletedRef.current) {\n            stackCompletedRef.current = false;\n            // re-init lenis so animation works again if user scrolls back up\n            setupLenis();\n          }\n        }\n      }\n    });\n    isUpdatingRef.current = false;\n  }, [itemScale, itemStackDistance, stackPosition, scaleEndPosition, baseScale, rotationAmount, blurAmount, useWindowScroll, onStackComplete, calculateProgress, parsePercentage, getScrollData, getElementOffset, destroyLenis, setupLenis]);\n\n  // keep a ref so handleScroll can call the latest updateCardTransforms\n  updateCardTransformsRef.current = updateCardTransforms;\n  useLayoutEffect(() => {\n    const scroller = scrollerRef.current;\n    if (!scroller) return;\n    const cards = Array.from(useWindowScroll ? document.querySelectorAll('.scroll-stack-card') : scroller.querySelectorAll('.scroll-stack-card'));\n    cardsRef.current = cards;\n    const transformsCache = lastTransformsRef.current;\n    cards.forEach((card, i) => {\n      if (i < cards.length - 1) {\n        card.style.marginBottom = `${itemDistance}px`;\n      }\n      card.style.willChange = 'transform, filter';\n      card.style.transformOrigin = 'top center';\n      card.style.backfaceVisibility = 'hidden';\n      card.style.transform = 'translateZ(0)';\n      card.style.webkitTransform = 'translateZ(0)';\n      card.style.perspective = '1000px';\n      card.style.webkitPerspective = '1000px';\n    });\n\n    // ensure Lenis is set up for the first time\n    setupLenis();\n\n    // initial transform pass\n    updateCardTransforms();\n    return () => {\n      // cleanup: cancel raf and destroy lenis\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (lenisRef.current) {\n        try {\n          lenisRef.current.destroy();\n        } catch (e) {}\n      }\n      stackCompletedRef.current = false;\n      cardsRef.current = [];\n      transformsCache.clear();\n      isUpdatingRef.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [itemDistance, itemScale, itemStackDistance, stackPosition, scaleEndPosition, baseScale, scaleDuration, rotationAmount, blurAmount, useWindowScroll, onStackComplete]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `scroll-stack-scroller ${className}`.trim(),\n    ref: scrollerRef,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"scroll-stack-inner\",\n      children: [children, /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"scroll-stack-end\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 363,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 360,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 359,\n    columnNumber: 5\n  }, this);\n};\n_s(ScrollStack, \"PqvRuqoFDMuSZnRxJLamunAb4QA=\");\n_c2 = ScrollStack;\nexport default ScrollStack;\nvar _c, _c2;\n$RefreshReg$(_c, \"ScrollStackItem\");\n$RefreshReg$(_c2, \"ScrollStack\");","map":{"version":3,"names":["useLayoutEffect","useRef","useCallback","Lenis","jsxDEV","_jsxDEV","ScrollStackItem","children","itemClassName","className","trim","fileName","_jsxFileName","lineNumber","columnNumber","_c","ScrollStack","itemDistance","itemScale","itemStackDistance","stackPosition","scaleEndPosition","baseScale","scaleDuration","rotationAmount","blurAmount","useWindowScroll","onStackComplete","_s","scrollerRef","stackCompletedRef","animationFrameRef","lenisRef","cardsRef","lastTransformsRef","Map","isUpdatingRef","calculateProgress","scrollTop","start","end","parsePercentage","value","containerHeight","includes","parseFloat","getScrollData","window","scrollY","innerHeight","scrollContainer","document","documentElement","scroller","current","clientHeight","getElementOffset","element","rect","getBoundingClientRect","top","offset","el","offsetParent","offsetTop","destroyLenis","cancelAnimationFrame","destroy","e","setupLenis","lenis","duration","easing","t","Math","min","pow","smoothWheel","touchMultiplier","infinite","wheelMultiplier","lerp","syncTouch","syncTouchLerp","raf","time","requestAnimationFrame","on","handleScroll","wrapper","content","querySelector","gestureOrientationHandler","normalizeWheel","touchInertiaMultiplier","touchInertia","updateCardTransformsRef","updateCardTransforms","_scrollerRef$current","length","stackPositionPx","scaleEndPositionPx","endElement","endElementTop","forEach","card","i","cardTop","triggerStart","triggerEnd","pinStart","pinEnd","scaleProgress","targetScale","scale","rotation","blur","topCardIndex","j","jCardTop","jTriggerStart","depthInStack","max","translateY","isPinned","newTransform","round","lastTransform","get","hasChanged","abs","transform","filter","style","set","cards","Array","from","querySelectorAll","transformsCache","marginBottom","willChange","transformOrigin","backfaceVisibility","webkitTransform","perspective","webkitPerspective","clear","ref","_c2","$RefreshReg$"],"sources":["/Users/nourelkilany/Desktop/year 4 /java/myy/src/animation/ScrollStack.jsx"],"sourcesContent":["import { useLayoutEffect, useRef, useCallback } from 'react';\nimport Lenis from 'lenis';\nimport './ScrollStack.css';\n\nexport const ScrollStackItem = ({ children, itemClassName = '' }) => (\n  <div className={`scroll-stack-card ${itemClassName}`.trim()}>{children}</div>\n);\n\nconst ScrollStack = ({\n  children,\n  className = '',\n  itemDistance = 100,\n  itemScale = 0.03,\n  itemStackDistance = 30,\n  stackPosition = '20%',\n  scaleEndPosition = '10%',\n  baseScale = 0.85,\n  scaleDuration = 0.5,\n  rotationAmount = 0,\n  blurAmount = 0,\n  useWindowScroll = false,\n  onStackComplete\n}) => {\n  const scrollerRef = useRef(null);\n  const stackCompletedRef = useRef(false);\n  const animationFrameRef = useRef(null);\n  const lenisRef = useRef(null);\n  const cardsRef = useRef([]);\n  const lastTransformsRef = useRef(new Map());\n  const isUpdatingRef = useRef(false);\n\n  const calculateProgress = useCallback((scrollTop, start, end) => {\n    if (scrollTop < start) return 0;\n    if (scrollTop > end) return 1;\n    return (scrollTop - start) / (end - start);\n  }, []);\n\n  const parsePercentage = useCallback((value, containerHeight) => {\n    if (typeof value === 'string' && value.includes('%')) {\n      return (parseFloat(value) / 100) * containerHeight;\n    }\n    return parseFloat(value);\n  }, []);\n\n  const getScrollData = useCallback(() => {\n    if (useWindowScroll) {\n      return {\n        scrollTop: window.scrollY,\n        containerHeight: window.innerHeight,\n        scrollContainer: document.documentElement\n      };\n    } else {\n      const scroller = scrollerRef.current;\n      return {\n        scrollTop: scroller ? scroller.scrollTop : 0,\n        containerHeight: scroller ? scroller.clientHeight : window.innerHeight,\n        scrollContainer: scroller || document.documentElement\n      };\n    }\n  }, [useWindowScroll]);\n\n  const getElementOffset = useCallback(\n    element => {\n      if (!element) return 0;\n      if (useWindowScroll) {\n        const rect = element.getBoundingClientRect();\n        return rect.top + window.scrollY;\n      } else {\n        // offsetTop relative to scroller container; ensure correct when scroller is used\n        let offset = 0;\n        let el = element;\n        while (el && el !== scrollerRef.current && el.offsetParent) {\n          offset += el.offsetTop;\n          el = el.offsetParent;\n        }\n        if (el === scrollerRef.current && element.offsetTop) {\n          // element.offsetTop already included, but ensure consistent calculation\n          return offset;\n        }\n        return offset || element.offsetTop || 0;\n      }\n    },\n    [useWindowScroll]\n  );\n\n  const destroyLenis = useCallback(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n    if (lenisRef.current) {\n      try {\n        lenisRef.current.destroy();\n      } catch (e) {\n        // ignore if already destroyed\n      }\n      lenisRef.current = null;\n    }\n  }, []);\n\n  const setupLenis = useCallback(() => {\n    // Do nothing if lenis already exists\n    if (lenisRef.current) return lenisRef.current;\n\n    if (useWindowScroll) {\n      const lenis = new Lenis({\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        wheelMultiplier: 1,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075\n      });\n\n      const raf = time => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n\n      lenis.on('scroll', handleScroll);\n      animationFrameRef.current = requestAnimationFrame(raf);\n\n      lenisRef.current = lenis;\n      return lenis;\n    } else {\n      const scroller = scrollerRef.current;\n      if (!scroller) return null;\n\n      const lenis = new Lenis({\n        wrapper: scroller,\n        content: scroller.querySelector('.scroll-stack-inner'),\n        duration: 1.2,\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n        smoothWheel: true,\n        touchMultiplier: 2,\n        infinite: false,\n        gestureOrientationHandler: true,\n        normalizeWheel: true,\n        wheelMultiplier: 1,\n        touchInertiaMultiplier: 35,\n        lerp: 0.1,\n        syncTouch: true,\n        syncTouchLerp: 0.075,\n        touchInertia: 0.6\n      });\n\n      const raf = time => {\n        lenis.raf(time);\n        animationFrameRef.current = requestAnimationFrame(raf);\n      };\n\n      lenis.on('scroll', handleScroll);\n      animationFrameRef.current = requestAnimationFrame(raf);\n\n      lenisRef.current = lenis;\n      return lenis;\n    }\n  }, [useWindowScroll]); // handleScroll declared later, but used via hoisting\n\n  // handleScroll must be declared before usage in setupLenis; to avoid circular reference,\n  // define here as function ref using callback which calls updateCardTransforms\n  const updateCardTransformsRef = useRef(null);\n\n  const handleScroll = useCallback(() => {\n    if (updateCardTransformsRef.current) updateCardTransformsRef.current();\n  }, []);\n\n  const updateCardTransforms = useCallback(() => {\n    if (!cardsRef.current.length || isUpdatingRef.current) return;\n\n    isUpdatingRef.current = true;\n\n    const { scrollTop, containerHeight } = getScrollData();\n    const stackPositionPx = parsePercentage(stackPosition, containerHeight);\n    const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\n\n    const endElement = useWindowScroll\n      ? document.querySelector('.scroll-stack-end')\n      : scrollerRef.current?.querySelector('.scroll-stack-end');\n\n    const endElementTop = endElement ? getElementOffset(endElement) : 0;\n\n    cardsRef.current.forEach((card, i) => {\n      if (!card) return;\n\n      const cardTop = getElementOffset(card);\n      const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\n      const triggerEnd = cardTop - scaleEndPositionPx;\n      const pinStart = triggerStart;\n      const pinEnd = endElementTop - containerHeight / 2;\n\n      const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\n      const targetScale = baseScale + i * itemScale;\n      const scale = 1 - scaleProgress * (1 - targetScale);\n      const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\n\n      let blur = 0;\n      if (blurAmount) {\n        let topCardIndex = 0;\n        for (let j = 0; j < cardsRef.current.length; j++) {\n          const jCardTop = getElementOffset(cardsRef.current[j]);\n          const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\n          if (scrollTop >= jTriggerStart) {\n            topCardIndex = j;\n          }\n        }\n\n        if (i < topCardIndex) {\n          const depthInStack = topCardIndex - i;\n          blur = Math.max(0, depthInStack * blurAmount);\n        }\n      }\n\n      let translateY = 0;\n      const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\n\n      if (isPinned) {\n        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\n      } else if (scrollTop > pinEnd) {\n        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\n      }\n\n      const newTransform = {\n        translateY: Math.round(translateY * 100) / 100,\n        scale: Math.round(scale * 1000) / 1000,\n        rotation: Math.round(rotation * 100) / 100,\n        blur: Math.round(blur * 100) / 100\n      };\n\n      const lastTransform = lastTransformsRef.current.get(i);\n      const hasChanged =\n        !lastTransform ||\n        Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 ||\n        Math.abs(lastTransform.scale - newTransform.scale) > 0.001 ||\n        Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 ||\n        Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\n\n      if (hasChanged) {\n        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;\n        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';\n\n        card.style.transform = transform;\n        card.style.filter = filter;\n\n        lastTransformsRef.current.set(i, newTransform);\n      }\n\n      // LAST CARD: determine completion\n      if (i === cardsRef.current.length - 1) {\n        // The stack is considered complete when the page scrolls past the pinEnd\n        if (scrollTop > pinEnd) {\n          if (!stackCompletedRef.current) {\n            stackCompletedRef.current = true;\n            // Call the callback\n            onStackComplete?.();\n\n            // Destroy Lenis to release control to native page scroll\n            destroyLenis();\n          }\n        } else {\n          // If user scrolls back up above pinEnd, mark as not completed and re-init Lenis\n          if (stackCompletedRef.current) {\n            stackCompletedRef.current = false;\n            // re-init lenis so animation works again if user scrolls back up\n            setupLenis();\n          }\n        }\n      }\n    });\n\n    isUpdatingRef.current = false;\n  }, [\n    itemScale,\n    itemStackDistance,\n    stackPosition,\n    scaleEndPosition,\n    baseScale,\n    rotationAmount,\n    blurAmount,\n    useWindowScroll,\n    onStackComplete,\n    calculateProgress,\n    parsePercentage,\n    getScrollData,\n    getElementOffset,\n    destroyLenis,\n    setupLenis\n  ]);\n\n  // keep a ref so handleScroll can call the latest updateCardTransforms\n  updateCardTransformsRef.current = updateCardTransforms;\n\n  useLayoutEffect(() => {\n    const scroller = scrollerRef.current;\n    if (!scroller) return;\n\n    const cards = Array.from(\n      useWindowScroll\n        ? document.querySelectorAll('.scroll-stack-card')\n        : scroller.querySelectorAll('.scroll-stack-card')\n    );\n\n    cardsRef.current = cards;\n    const transformsCache = lastTransformsRef.current;\n\n    cards.forEach((card, i) => {\n      if (i < cards.length - 1) {\n        card.style.marginBottom = `${itemDistance}px`;\n      }\n      card.style.willChange = 'transform, filter';\n      card.style.transformOrigin = 'top center';\n      card.style.backfaceVisibility = 'hidden';\n      card.style.transform = 'translateZ(0)';\n      card.style.webkitTransform = 'translateZ(0)';\n      card.style.perspective = '1000px';\n      card.style.webkitPerspective = '1000px';\n    });\n\n    // ensure Lenis is set up for the first time\n    setupLenis();\n\n    // initial transform pass\n    updateCardTransforms();\n\n    return () => {\n      // cleanup: cancel raf and destroy lenis\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n      if (lenisRef.current) {\n        try {\n          lenisRef.current.destroy();\n        } catch (e) {}\n      }\n      stackCompletedRef.current = false;\n      cardsRef.current = [];\n      transformsCache.clear();\n      isUpdatingRef.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    itemDistance,\n    itemScale,\n    itemStackDistance,\n    stackPosition,\n    scaleEndPosition,\n    baseScale,\n    scaleDuration,\n    rotationAmount,\n    blurAmount,\n    useWindowScroll,\n    onStackComplete\n  ]);\n\n  return (\n    <div className={`scroll-stack-scroller ${className}`.trim()} ref={scrollerRef}>\n      <div className=\"scroll-stack-inner\">\n        {children}\n        {/* Spacer so the last pin can release cleanly */}\n        <div className=\"scroll-stack-end\" />\n      </div>\n    </div>\n  );\n};\n\nexport default ScrollStack;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}